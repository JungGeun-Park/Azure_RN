trigger:
- main

pool:
  name: APPSEALING

parameters:
- name: APPLE_ID
  type: string
  default: 'puzznic@inka.co.kr'
- name: APP_SPECIFIC_PASSWORD
  type: string
  default: 'qbrz-hmfz-robj-eohm'
- name: TEAM_ID
  type: string
  default: '22X77ENQ2H'
- name: PROVISIONING_PROFILE_NAME
  type: string
  default: 'AppSealing Wildcard Distribution Profile'

steps:
- script: |
    # Automatically detect the app name from the iOS directory
    IOS_PATH="ios"
    if [ -d "$IOS_PATH" ]; then
        APP_NAME=$(ls "$IOS_PATH" | grep ".xcodeproj" | sed 's/.xcodeproj//')
        if [ -z "$APP_NAME" ]; then
            echo "No Xcode project found in the iOS directory."
            exit 1
        fi
    else
        echo "iOS directory not found."
        exit 1
    fi

    echo "Detected app name: $APP_NAME"
    echo "##vso[task.setvariable variable=APP_NAME]$APP_NAME"
  displayName: 'Detect App Name'

- script: |
    # Define paths for provisioning profile and keychain setup
    P12_CERT_PATH="$(Build.SourcesDirectory)/ios/distribution.p12"
    PROVISIONING_PROFILE_PATH="$(Build.SourcesDirectory)/ios/profile.mobileprovision"
    KEYCHAIN_PATH="$HOME/Library/Keychains/temp-keychain.keychain-db"
    KEYCHAIN_PASSWORD="temp123"

    # Create a temporary keychain for code signing
    if security list-keychains | grep -q "temp-keychain.keychain-db"; then
        echo "Deleting existing temporary keychain..."
        security delete-keychain "$KEYCHAIN_PATH"
    fi

    echo "Creating temporary keychain..."
    security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

    echo "Setting temporary keychain as default..."
    security list-keychains -d user -s "$KEYCHAIN_PATH"
    security default-keychain -s "$KEYCHAIN_PATH"
    security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
    security set-keychain-settings -lut 3600 "$KEYCHAIN_PATH"

    echo "Importing distribution certificate (PKCS#12) into temporary keychain..."
    security import "$P12_CERT_PATH" -k "$KEYCHAIN_PATH" -P "123456" -T /usr/bin/codesign
    security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
  displayName: 'Setup Temporary Keychain and Install Certificate'

- script: |
    # Increment build number for iOS (Info.plist)
    INFO_PLIST_PATH="ios/${APP_NAME}/Info.plist"

    if [ -f "$INFO_PLIST_PATH" ]; then
        # 1. 변수 확장 문제 해결
        CURRENT_BUILD_NUMBER=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$INFO_PLIST_PATH" 2>/dev/null || echo "1")
        
        # 2. 조건식 수정 (정규표현식 사용)
        if [[ "$CURRENT_BUILD_NUMBER" =~ \$\([A-Z_]+\) ]]; then
            echo "Resetting invalid build number format..."
            /usr/libexec/PlistBuddy -c "Set :CFBundleVersion 1" "$INFO_PLIST_PATH"
            CURRENT_BUILD_NUMBER=1
        fi

        # 3. 빌드 번호 증가
        NEW_BUILD_NUMBER=$((CURRENT_BUILD_NUMBER + 1))
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $NEW_BUILD_NUMBER" "$INFO_PLIST_PATH"
        echo "Updated iOS build number to $NEW_BUILD_NUMBER."

        # 4. 배포 대상 설정 (안전한 추가)
        if ! /usr/libexec/PlistBuddy -c "Print :IPHONEOS_DEPLOYMENT_TARGET" "$INFO_PLIST_PATH" &>/dev/null; then
            /usr/libexec/PlistBuddy -c "Add :IPHONEOS_DEPLOYMENT_TARGET string 12.0" "$INFO_PLIST_PATH"
        fi
        /usr/libexec/PlistBuddy -c "Set :IPHONEOS_DEPLOYMENT_TARGET 12.0" "$INFO_PLIST_PATH"
        echo "Set deployment target to iOS 12.0."
    else
        echo "##vso[task.logissue type=error] Info.plist not found at $INFO_PLIST_PATH"
        exit 1
    fi
  displayName: 'Increment Build Number and Set Deployment Target'

- script: |
    # 디스크 공간 정리
    echo "Cleaning up disk space..."
    rm -rf ~/Library/Caches/* || true
    rm -rf ~/Library/Developer/Xcode/DerivedData/* || true
    rm -rf ~/Library/Developer/Xcode/iOS\ DeviceSupport/* || true
    df -h /
  displayName: 'Clean Disk Space'

# Node.js 설치
- task: NodeTool@0
  inputs:
    versionSpec: '18.x'  # React Native와 호환되는 안정적인 버전 사용
  displayName: 'Install Node.js'

# Node 모듈 완전 재설치 (clean install)
- script: |
    echo "Removing existing node_modules..."
    rm -rf node_modules
    rm -f package-lock.json

    echo "Reinstalling Node modules..."
    npm install --legacy-peer-deps

    echo "Verifying React Native scripts..."
    if [ -f "node_modules/react-native/scripts/react_native_pods.rb" ]; then
      echo "✅ React Native scripts found!"
    else
      echo "❌ React Native scripts missing! Attempting to restore..."
      npm audit fix --force
    fi
  displayName: 'Reinstall Node Modules'

# ffi 라이브러리 문제 해결
- script: |
    export GEM_HOME=$HOME/.gem
    export PATH=$GEM_HOME/bin:$PATH
    
    echo "Restoring ffi gem..."
    gem pristine ffi --version 1.16.3 || echo "Failed to restore ffi, continuing anyway..."
  displayName: 'Fix Ruby FFI'

# CocoaPods 설치 (사용자 모드)
- script: |
    export GEM_HOME=$HOME/.gem
    export PATH=$GEM_HOME/bin:$PATH
    
    echo "Installing CocoaPods..."
    gem install cocoapods --user-install
    
    echo "CocoaPods version:"
    export PATH=$HOME/.gem/ruby/*/bin:$PATH
    which pod || echo "Pod not found in PATH"
    pod --version || echo "Pod command not available"
  displayName: 'Install CocoaPods'

# Podfile 수정 (fallback 메커니즘 추가)
- script: |
    cd ios
    
    echo "Backing up original Podfile..."
    cp Podfile Podfile.bak
    
    echo "Modifying Podfile to ensure compatibility..."
    cat > Podfile << 'EOF'
    # 직접 상대 경로로 참조 (fallback 메커니즘)
    begin
      require_relative '../node_modules/react-native/scripts/react_native_pods'
      require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules'
    rescue => e
      # 기존 방식 시도 (fallback)
      Pod::UI.warn "Failed to load with require_relative. Falling back to node resolve. Error: #{e.message}"
      require Pod::Executable.execute_command('node', ['-e', 
        'console.log(require.resolve("react-native/scripts/react_native_pods"));'
      ]).strip
    end

    platform :ios, min_ios_version_supported
    prepare_react_native_project!

    # 원본 Podfile에서 이 부분 이후 내용 복사
    linkage = ENV['USE_FRAMEWORKS']
    if linkage != nil
      Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
      use_frameworks! :linkage => linkage.to_sym
    end

    target '${APP_NAME}' do
      config = use_native_modules!
      use_react_native!(
        :path => config[:reactNativePath],
        # 앱 절대 경로
        :app_path => "#{Pod::Config.instance.installation_root}/.."
      )
    end

    post_install do |installer|
      react_native_post_install(
        installer,
        config[:reactNativePath],
        :mac_catalyst_enabled => false
      )
    end
    EOF
    
    cd ..
  displayName: 'Fix Podfile'

# Pod 설치 (포드 캐시 정리 후)
- script: |
    export GEM_HOME=$HOME/.gem
    export PATH=$GEM_HOME/bin:$PATH

    echo "Installing CocoaPods..."
    gem install cocoapods --user-install

    echo "Cleaning Pod cache and installing Pods..."
    cd ios
    rm -rf Pods Podfile.lock ~/Library/Caches/CocoaPods
    pod deintegrate || true
    pod install --repo-update
  displayName: 'Install CocoaPods'
    
- script: |  # Bundle ID 추출 단계 추가
    INFO_PLIST_PATH="ios/${APP_NAME}/Info.plist"
    if [ -f "$INFO_PLIST_PATH" ]; then
        BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$INFO_PLIST_PATH")
        echo "##vso[task.setvariable variable=BUNDLE_ID]$BUNDLE_ID"
    else
        echo "##vso[task.logissue type=error] Info.plist not found!"
        exit 1
    fi
  displayName: 'Extract Bundle ID'

- script: |  # ExportOptions.plist 생성 단계 수정
    EXPORT_DIR="$(Build.ArtifactStagingDirectory)"
    mkdir -p "$EXPORT_DIR"
    
    cat << EOF > "$EXPORT_DIR/ExportOptions.plist"
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
        <key>method</key>
        <string>app-store</string>
        <key>teamID</key>
        <string>${{ parameters.TEAM_ID }}</string>
        <key>provisioningProfiles</key>
        <dict>
            <key>$BUNDLE_ID</key>
            <string>${{ parameters.PROVISIONING_PROFILE_NAME }}</string>
        </dict>
    </dict>
    </plist>
    EOF
  
  displayName: 'Generate ExportOptions.plist'

- script: |
    echo "Creating Bridging Header..."
    cat > ios/Azure_RN078-Bridging-Header.h << 'EOF'
    #import <React/RCTBridgeModule.h>
    #import <React/RCTBridge.h>
    #import <React/RCTEventDispatcher.h>
    #import <React/RCTRootView.h>
    #import <React/RCTUtils.h>
    #import <React/RCTConvert.h>
    #import <React/RCTBundleURLProvider.h>
    EOF
    
    echo "Updating project file with sed instead of plutil..."
    cd ios
    sed -i '' 's|SWIFT_OBJC_BRIDGING_HEADER = .*;|SWIFT_OBJC_BRIDGING_HEADER = "Azure_RN078-Bridging-Header.h";|g' Azure_RN078.xcodeproj/project.pbxproj || echo "Sed command failed, will use direct reference in build command instead"
    cd ..
  displayName: 'Setup Bridging Header with sed'

- script: |  # 단일 Build and Export IPA 단계로 통합
    EXPORT_DIR="$(Build.ArtifactStagingDirectory)"
    ARCHIVE_PATH="$EXPORT_DIR/${APP_NAME}.xcarchive"
    
    # 1. .xcworkspace 존재 확인
    WORKSPACE_PATH="$(Build.SourcesDirectory)/ios/${APP_NAME}.xcworkspace"
    if [ ! -d "$WORKSPACE_PATH" ]; then
        echo "##vso[task.logissue type=error] .xcworkspace not found: $WORKSPACE_PATH"
        exit 1
    fi

    # 2. 아카이브 빌드
    xcodebuild clean archive \
      -workspace "${APP_NAME}.xcworkspace" \
      -scheme "${APP_NAME}" \
      -sdk iphoneos \
      -configuration Release \
      CODE_SIGN_IDENTITY="Apple Distribution" \
      DEVELOPMENT_TEAM="$(TEAM_ID)" \
      PROVISIONING_PROFILE_SPECIFIER="$(PROVISIONING_PROFILE_NAME)" \
      SWIFT_OBJC_BRIDGING_HEADER="Azure_RN078-Bridging-Header.h" \
      -archivePath "$(Build.ArtifactStagingDirectory)/${APP_NAME}.xcarchive"

    # 3. IPA 내보내기
    xcodebuild -exportArchive \
      -archivePath "$ARCHIVE_PATH" \
      -exportOptionsPlist "$EXPORT_DIR/ExportOptions.plist" \
      -exportPath "$EXPORT_DIR"
    
    echo "IPA exported to: $EXPORT_DIR"
  displayName: 'Build and Export IPA'

- script: |
    # Upload the IPA file to TestFlight using altool
    IPA_PATH=$(find "$(Build.ArtifactStagingDirectory)" -type f -name "*.ipa" | head -n 1)

    if [ -f "$IPA_PATH" ]; then
        xcrun altool --upload-app \
          -f "$IPA_PATH" \
          -t ios \
          -u "${{ parameters.APPLE_ID }}" \
          -p "${{ parameters.APP_SPECIFIC_PASSWORD }}"

        echo "Uploaded IPA to TestFlight successfully."
    else
        echo "IPA file not found. Skipping upload."
        exit 1
    fi
  displayName: 'Upload to TestFlight'

- script: |
    # Cleanup temporary keychain and build artifacts
    TEMP_KEYCHAIN_PATH="$HOME/Library/Keychains/temp-keychain.keychain-db"

    if [ -f "$TEMP_KEYCHAIN_PATH" ]; then
        security delete-keychain "$TEMP_KEYCHAIN_PATH"
        echo "Temporary keychain deleted successfully."
    else
        echo "Temporary keychain not found. Skipping deletion."
    fi

    rm -rf "$(Build.ArtifactStagingDirectory)" ios/build ios/Pods ios/Podfile.lock

    echo "Cleanup completed."
  displayName: 'Cleanup Temporary Files'
